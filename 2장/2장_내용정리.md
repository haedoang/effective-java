### 2장) 객채 생성과 파괴
#### 아이템 1) 생성자 대신 정적 팩터리 메서드를 고려하라
- 장점
  - 팩터리 메서드는 `이름`을 가질 수 있다. 
    - 코드의 가독성을 높혀준다.
  - `호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.`
    - 불필요한 객체 생성을 막을 수 있다. 
  - `반환 타입의 하위 타입 객체를 반환할 수 있다.` 
    - 반환 객체의 타입을 유연하게 함으로써 코드의 활용을 높일 수 있다.
  - `입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.` 
     - 매개변수를 오브젝트 내에서 조건에 따라 반환 타입을 다르게 할 수 있다.
  - `정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.`
    - ex) JDBC 사용 시 driver instance 생성
- 단점 
  - `정적 팩토리 메서드만 제공하는 하위 클래스를 만들 수 없다.`
    - 해당 객체 생성을 팩토리 메서드로 제한함으로써 객체 생성을 유도함으로써 오용을 방지할 수 있다. 
  - `프로그래머가 찾기 어렵다`
    - 팩터리 메서드 패턴을 만들면 개선할 수 있을 것 같다.
 
  
#### 아이템 2) 생성자에 매개변수가 많다면 빌더를 고려하라
- 다양한 생성자 패턴 
   1) 점층적 생성자 패턴(Telescoping Constructor Pattern)
       - 확장성이 좋지 않다.
       - 매개변수가 많아질수록 클라이언트 코드를 작성하거나 읽기 어려워진다.
   2) 자바빈즈 패턴(JavaBeans Pattern)
       - 점층적 생성자 패턴에 비해 코드가 간결하고 읽기 쉽다.
       - 객체를 생성하기 위해 메서드를 여러개 호출해야 한다.
       - 객체가 완전히 생성(필수적인 메서드 호출이 끝났음을 의미)되기 전까지 `일관성이 무너진 상태`에 놓이게 된다.
       - `불변타입으로 만들 수 없다.` (setter 를 통해 값을 할당하기 때문)
   3) 빌더 패턴(Builder Pattern)
       - `객체를 불변 상태로 생성`할 수 있다.
       - 메서드 연쇄(method chaining)을 사용하기 때문에 코드가 읽기 쉽다.
       - builder 를 통한 객체 생성 시점에 객체 유효성을 검증할 수 있다.
       - 확장성이 용이하여 계층적으로 설계된 클래스와 함께 사용하기 좋다.
 

#### 아이템 3) private 생성자나 열거 타입으로 싱글톤임을 보증하라.
- 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트에 사용된다.
- 싱글톤을 만드는 여러가지 방법
   1) public static final 필드 방식의 싱글턴
       - 필드가 public 이기 때문에 해당 클래스가 싱글턴임을 api에 명백히 드러낸다.
       - 코드가 간결하다.
       - `AccessibleObject.setAccessible`을 사용하면 싱글톤을 보장할수 없다. (생성자를 수정하여 생성자가 2번 호출되는 경우 예외처리 한다)
   2) 정적 팩터리 방식의 싱글턴
       - API 변경없이 인스턴스 제공 방식을(프로토타입/싱글톤) 자유롭게 변경할 수 있다. 
       - 제네릭 싱글턴 팩터리로 만들 수 있다.
   1,2) 공통적인 단점 
       - 역직렬화 시 싱글턴을 보장할 수 없다.
       - 싱글턴임을 보장하기 위해서는 필드를 `transient` 상태로 변경 후 `readResolve` 메서드를 사용하여 진짜 인스턴스를 반환해야한다.
   3) 열거 타입의 싱글턴 
       - enum 외의 클래스를 상속해야 한다면 사용할 수 없다. 

#### 아이템 4) 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 메소드와 정적 필드만을 담은 클래스(유틸리티 클래스)
  - 인스턴스 생성을 목적으로 하지 않는다.
  - 컴파일러가 만들어주는 기본 생성자 때문에 오용할 수 있으므로 접근제한자를 명시적으로 `private`으로 사용하자.

#### 아이템 5) 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- `사용하는 자원에 따라 동작이 달라지는 클래스`에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
  - 유연하지 못하다(확장의 어려움)
  - 테스트하기 어렵다
- `인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식(의존 객체 주입)`을 사용하자.
  - 유연성과 테스트가 용이하다
- 정리) 
  - 클래스가 내부적으로 하나 이상의 자원에 의존하고, 클래스 동작에 영향을 준다면 싱글턴, 정적 유틸리티 클래스는 좋지 않다.
  - 의존 객체 주입을 활용하자.
 
#### 아이템 6) 불필요한 객체 생성을 피하라
- 객체 생성에는 비용이 따르기 때문에 불필요한 객체 생성을 줄인다면 성능을 더 높일 수 있다.
- 예시 
    1) Pattern 객체의 사용 
        - `String.matches` 메서드 내부에서 호출 시 Pattern 객체를 생성한다.
        - 호출의 개수마다 객체가 생성되기 떄문에 반복해 사용하기 적합하지 않다.
        - `static 변수의 사용`으로 값비싼 객체를 재사용할 것
    2) 불필요한 오토박싱은 성능 저하를 일으킨다. 
        - `item6.AutoBoxingTest` 내 오토박싱의 테스트는 오토박싱 사용의 성능 비교를 나타내는 테스트이다.
        - 오브젝트 타입의 값을 변경할 때마다 오브젝트가 생성되기 떄문에 `Integer.MAX_LENGTH` 개 만큼의 객체가 생성된다.
- 정리)
  - 불필요한 객체 생성이 있는지 확인하여 자주 호출되는 객체의 경우 `static 변수`로 선언한다.
  - 불필요한 오토박싱을 사용하지 말 것.
  
#### 아이템 7) 다 쓴 객체 참조를 해제하라
- `다 쓴 참조(obsolete reference)`는 메모리 누수를 유발한다.
- 다 쓴 객체 참조는 `null` 값으로 처리할 경우 가바지 콜렉터 수집의 대상이 된다.
- 객체 참조를 `null` 처리하는 일은 예외적인경우여야 한다.
  - 사용 않는 객체들을 전부 null 값으로 하나하나 변경하는 것은 바람직하지 못하다.
  - 참조를 담은 변수를 유효 범위 밖으로 밀어내어 해결하도록 한다.
- 자기 메모리를 직접 관리하는 클래스는 메모리 누수에 주의해야 한다.
- 캐시 또한 메모리 누스를 일으키는 주범이다.
  - `java.util.WeakHashMap`


#### 아이템 8) finalizer 와 cleaner 사용을 피해라
- 자바의 객체 소멸자 `finalizer`, `cleaner` 
- `finalizer`는 예측할 수 없고, 상황에 따라 위험할 수 있어서 일반적으로 불필요하다.
- `cleaner`는 finalizer보다 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
  - 성능 이슈를 유발한다.
  - finalizer 공격에 노출되어 심각한 보안 문제를 유발할 수 있다(12장 참조)
- `AutoClosable`을 구현하여 finalize, cleaner 를 대신하자(jdk 11)
- try-with-resource 는 객체의 소멸을 자등으로 처리해준다.
- 정리)
  - 직접적인 가비지 컬렉터의 사용은 성능 이슈와 불확실성이 있을 수 있기 때문에 주의해야한다.
  - try-with-resource 를 사용하여 객체 소멸을 처리할 것 

  