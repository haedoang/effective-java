### 2장) 객채 생성과 파괴
#### 아이템 1) equals는 일반 규약을 지켜 재정의하라
 - 아래와 같은 경우 재정의하지 않는 것이 최선이다.
    1. `각 인스턴스가 본질적으로 고유하다` 
    2. `인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다` ex) `java.util.regex.Pattern` 
    3. `상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다` 
        - `Set`, `List`, `Map` 같은 콜렉션 객체는 Abstract- 객체의 equals 를 상속받아 사용한다.
    4. `클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다`

 - equals 메서드 동치 관계(참조값은 모두 null이 아님)
    1. 반사성(reflexivity) : x.equals(x) 
    2. 대칭성(symmetry) : x.equals(y) => y.equals(x)
    3. 추이성(trasitivity) : x.equals(y) && y.equals(z) => x.equals(z)
    4. 일관성(consistency) : x.equals(y) => always true
    5. null-아님 : x.equals(null) => false

 - 상속으로 구현되어 있는 경우 동치 관계를 성립시키기 어렵다. 
   - 상위 타입과 하위 타입의 비교 시 대칭성이 위배된다.
   - 대칭성을 고려하여 상위 타입에 대해서만 비교 시 추이성이 위배된다.
   - instaneof 검사를 getclass 검사로 바꿀 경우 리스코프 치환 원칙이 위배된다.
   
 - 상속 대신 컴포지션(Composition)을 사용하자.
   - 컴포지션은 상속받으려는 대상을 필드로 두어 메서드로 반환할 수 있도록 설계한 방식을 말한다. 
   - 기존 클래스가 변경이 되어도 안전하다.

 - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다. ex) java.net.URL  

 - equals 메서드 구현 방법
   1. `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
   2. `instanceof` 연산자로 입력이 볼바른 타입인지 확인한다.
   3. `입력을 올바른 타입으로 형변환한다.` 
   4. `입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일칠하는지 하나씩 검사한다.`
      - 타입별 비교 
         - 기본 타입 : `==`
         - float, double : `Float.compare(), Double.comare()`. 
         - null 도 정상값으로 취급할 경우 : Objects.equals() 
   
 - equals 구현 시 확인할 사항
   1) 대칭적인가 
   2) 추이성이 있는가
   3) 일관적인가 
   
 - equals 재정의 시 hashCode도 재정의한다.(다음 장에서 학습)
 - equals의 매개변수를 특정 타입으로 비교하지 말 것(주의)

 - 정리) 꼭 필요한 경우가 아니라면 equals를 재정의하지 말자. 